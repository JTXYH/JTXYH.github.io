(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{602:function(t,a,v){"use strict";v.r(a);var _=v(6),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",[t._v("Java虚拟机内存与垃圾回收")])]),t._v(" "),v("h2",{attrs:{id:"jvm的架构模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm的架构模型"}},[t._v("#")]),t._v(" JVM的架构模型")]),t._v(" "),v("p",[t._v("Java编译器输入的指令流基本上是一种"),v("code",[t._v("基于栈的指令集架构")]),t._v("，另一种指令集架构是"),v("code",[t._v("基于寄存器的指令集架构")])]),t._v(" "),v("p",[t._v("基于"),v("code",[t._v("栈式架构的特点")])]),t._v(" "),v("ol",[v("li",[t._v("设计和实现更简单，适用于资源受限的系统")]),t._v(" "),v("li",[t._v("避开了寄存器的分配难题：使用"),v("code",[t._v("零地址指令方式分配")])]),t._v(" "),v("li",[t._v("指令流中的指令"),v("code",[t._v("大部分是零地址指令，其执行过程依赖于操作栈")]),t._v("。指令集更小，编译器容易实现")]),t._v(" "),v("li",[t._v("不需要硬件支持，"),v("code",[t._v("可移植性更好，更好实现跨平台")])])]),t._v(" "),v("p",[t._v("基于"),v("code",[t._v("寄存器架构的特点")])]),t._v(" "),v("ol",[v("li",[t._v("典型的应用是x86的二进制指令集：比如传统的PC和Android的Davlik虚拟机")]),t._v(" "),v("li",[t._v("指令集架构则完全依赖硬件，可移植性差")]),t._v(" "),v("li",[t._v("性能优秀和执行更高效")]),t._v(" "),v("li",[t._v("花费更少的指令去完成一项操作")]),t._v(" "),v("li",[t._v("在大部分情况下，基于"),v("code",[t._v("寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主")]),t._v("，而基于"),v("code",[t._v("栈式架构的指令集却是以零地址指令为主")])])]),t._v(" "),v("h2",{attrs:{id:"监控工具"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#监控工具"}},[t._v("#")]),t._v(" 监控工具")]),t._v(" "),v("ul",[v("li",[t._v("终端输入："),v("strong",[t._v("jconsole或者jvisualvm")])])]),t._v(" "),v("h2",{attrs:{id:"jvm内存区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存区"}},[t._v("#")]),t._v(" JVM内存区")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("线程私有")]),t._v("：程序计数器，虚拟机栈，本地方法栈")]),t._v(" "),v("li",[v("strong",[t._v("线程共有")]),t._v("：Java堆，方法区")])]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"JVM运行时数据区",href:"https://gitee.com/jtxyh/blogImg/raw/master/JVM运行时数据区.png"}},[v("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png",alt:"JVM运行时数据区"}})])]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"JVM类代码",href:"https://gitee.com/jtxyh/blogImg/raw/master/JVM类代码.png"}},[v("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/JVM%E7%B1%BB%E4%BB%A3%E7%A0%81.png",alt:"JVM类代码"}})]),t._v(" "),v("a",{attrs:{"data-fancybox":"",title:"JVM运行代码图",href:"https://gitee.com/jtxyh/blogImg/raw/master/JVM运行代码图.png"}},[v("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/JVM%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%9B%BE.png",alt:"JVM运行代码图"}})])]),t._v(" "),v("h3",{attrs:{id:"程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[t._v("#")]),t._v(" 程序计数器")]),t._v(" "),v("ul",[v("li",[t._v("指向"),v("strong",[t._v("当前线程")]),t._v("正在执行的字节码指令的"),v("strong",[t._v("地址(行号)")])]),t._v(" "),v("li",[t._v("作用：因为Java是多线程的，为了"),v("strong",[t._v("确保在多线程情况下的程序正常执行")])])]),t._v(" "),v("h3",{attrs:{id:"虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[t._v("#")]),t._v(" 虚拟机栈")]),t._v(" "),v("ul",[v("li",[t._v("存储当前线程"),v("strong",[t._v("运行方法")]),t._v("所需要的"),v("strong",[t._v("数据、指令、返回地址")])]),t._v(" "),v("li",[t._v("大小设置："),v("strong",[t._v("-Xss 1M")])])]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"虚拟机栈",href:"https://gitee.com/jtxyh/blogImg/raw/master/虚拟机栈.png"}},[v("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png",alt:"虚拟机栈"}})])]),t._v(" "),v("h4",{attrs:{id:"栈帧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈帧"}},[t._v("#")]),t._v(" 栈帧")]),t._v(" "),v("ul",[v("li",[t._v("每个方法在执行的同时都会创建一个"),v("strong",[t._v("栈帧")]),t._v("，包含了这个方法自己的相关数据")]),t._v(" "),v("li",[t._v("划分为：\n"),v("ol",[v("li",[v("strong",[t._v("局部变量表")])]),t._v(" "),v("li",[v("strong",[t._v("操作数栈")])]),t._v(" "),v("li",[v("strong",[t._v("动态连接")])]),t._v(" "),v("li",[v("strong",[t._v("返回地址")])])])])]),t._v(" "),v("h3",{attrs:{id:"本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[t._v("#")]),t._v(" 本地方法栈")]),t._v(" "),v("ul",[v("li",[t._v("本地方法栈是保存的是"),v("strong",[t._v("native方法的信息")]),t._v("，当一个JVM创建的线程调用native方法后，JVM不在为其在虚拟机栈中创建栈帧，JVM只是简单的动态链接并直接调用native方法")])]),t._v(" "),v("h3",{attrs:{id:"java堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java堆"}},[t._v("#")]),t._v(" Java堆")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("-Xms，-Xmx，-Xmn")])]),t._v(" "),v("li",[t._v("堆是非常重要的一部分，涉及到"),v("strong",[t._v("内存的分配(new 关键字，反射)与回收")])]),t._v(" "),v("li",[v("strong",[t._v("几乎所有的对象都是在堆中分配")])])]),t._v(" "),v("h3",{attrs:{id:"方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[t._v("#")]),t._v(" 方法区")]),t._v(" "),v("ul",[v("li",[t._v("主要存储"),v("strong",[t._v("类信息，常量，静态变量，即时编译期编译后的代码")])])]),t._v(" "),v("h3",{attrs:{id:"直接内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[t._v("#")]),t._v(" 直接内存")]),t._v(" "),v("p",[v("a",{attrs:{"data-fancybox":"",title:"JVM直接内存",href:"https://gitee.com/jtxyh/blogImg/raw/master/JVM直接内存.png"}},[v("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/JVM%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png",alt:"JVM直接内存"}})])]),t._v(" "),v("ul",[v("li",[t._v("所谓的"),v("strong",[t._v("零拷贝")]),t._v("就是在这块区域")]),t._v(" "),v("li",[v("strong",[t._v("不是虚拟机运行时数据区的一部分")]),t._v("，也不是java虚拟机规范中定义的内存区域")]),t._v(" "),v("li",[v("strong",[t._v("如果使用了NIO，这块区域会被频繁使用")]),t._v("，在java堆内可以用directByteBuffer对象直接引用并操作")]),t._v(" "),v("li",[v("strong",[t._v("这块内存不受java堆大小限制，但受本机总内存的限制")]),t._v("，可以通过MaxDirectMemorySize来设置(默认与堆内存最大值一样)，所以也会出现OOM异常")]),t._v(" "),v("li",[t._v("避免了在java堆和Native堆中"),v("strong",[t._v("来回的复制数据，能提高效率")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);