(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{630:function(v,t,_){"use strict";_.r(t);var a=_(6),r=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("div",{staticClass:"custom-block tip"},[_("p",[v._v("运行时数据区包括：方法区，堆，程序计数器，本地方法栈，虚拟机栈")])]),v._v(" "),_("h2",{attrs:{id:"jvm调优工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优工具"}},[v._v("#")]),v._v(" JVM调优工具")]),v._v(" "),_("ul",[_("li",[v._v("JDK命令行")]),v._v(" "),_("li",[v._v("Jmap")]),v._v(" "),_("li",[v._v("Eclipse:Memory Analyzer Tool")]),v._v(" "),_("li",[v._v("Jconsole")]),v._v(" "),_("li",[v._v("VisualVM")]),v._v(" "),_("li",[v._v("Jprofiler")]),v._v(" "),_("li",[v._v("Java Flight Recorder")]),v._v(" "),_("li",[v._v("GCViewer")]),v._v(" "),_("li",[v._v("GC Easy")])]),v._v(" "),_("h2",{attrs:{id:"基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"结构概览1",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210412144622.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210412144622.png",alt:"结构概览1"}})])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"结构概览2",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210412144704.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210412144704.png",alt:"结构概览2"}})])]),v._v(" "),_("ul",[_("li",[v._v("每个线程："),_("strong",[v._v("有独立包括程序计数器、栈、本地栈")])]),v._v(" "),_("li",[v._v("线程间共享："),_("strong",[v._v("堆，堆外内存（永久代或元空间、代码缓存）")])])]),v._v(" "),_("h2",{attrs:{id:"程序计数器（pc寄存器）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器（pc寄存器）"}},[v._v("#")]),v._v(" 程序计数器（PC寄存器）")]),v._v(" "),_("ul",[_("li",[v._v("名称"),_("strong",[v._v("Program Counter Register")]),v._v("，"),_("code",[v._v("JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟")])]),v._v(" "),_("li",[v._v("在JVM规范中，每个线程都有它自己的程序计数器，"),_("strong",[v._v("是线程私有的，生命周期与线程的生命周期保持一致")])]),v._v(" "),_("li",[v._v("任何时间一个线程只有一个方法在执行，也就是所谓的"),_("code",[v._v("当前方法")]),v._v("。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值(undefined)")]),v._v(" "),_("li",[v._v("它是唯一一个在Java虚拟机规范中"),_("strong",[v._v("没有规定OOM(内存溢出)的区域，没有GC(垃圾回收)")])])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"PC寄存器字节码操作",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210413104052.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210413104052.png",alt:"PC寄存器字节码操作"}})])]),v._v(" "),_("h3",{attrs:{id:"问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[v._v("#")]),v._v(" 问题")]),v._v(" "),_("p",[_("code",[v._v("使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址？")])]),v._v(" "),_("p",[v._v("因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行，JVM的字节码解释器就需要通过改变PC寄存器的值明确下一条应该执行什么样的字节码指令")]),v._v(" "),_("p",[_("code",[v._v("PC寄存器为什么会被设定为线程私有")])]),v._v(" "),_("p",[v._v("CPU在并发执行线程的时候会来回切换，"),_("strong",[v._v("为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的方法自然是为每一个线程都分配一个PC寄存器")]),v._v("，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况")]),v._v(" "),_("h2",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[v._v("#")]),v._v(" 虚拟机栈")]),v._v(" "),_("p",[v._v("内存中的栈与堆："),_("strong",[v._v("栈是运行时的单位，而堆是存储的单位")]),v._v("，栈解决程序如何执行，如何处理数据。堆解决的是数据存储问题，即数据怎么放，放在哪里。")]),v._v(" "),_("h3",{attrs:{id:"介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[v._v("#")]),v._v(" 介绍")]),v._v(" "),_("ul",[_("li",[v._v("Java虚拟机栈，早起也叫Java栈，"),_("strong",[v._v("每个线程创建时都会创建一个虚拟机栈")]),v._v("，内部保存一个个栈帧，对应着一次次的Java方法调用")]),v._v(" "),_("li",[v._v("生命周期和线程的一致")]),v._v(" "),_("li",[v._v("主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回")])]),v._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令")]),v._v(" "),_("li",[v._v("快速有效的存储方式，访问速度仅次于程序计数器")]),v._v(" "),_("li",[v._v("JVM直接对JAVA栈的操作只有两个\n"),_("ol",[_("li",[v._v("每个方法执行，伴随着进栈（入栈，压栈）")]),v._v(" "),_("li",[v._v("执行结束的出栈")])])]),v._v(" "),_("li",[_("strong",[v._v("栈不存在GC，但是存在OOM")]),v._v("，Java栈大小是动态或者固定不变的。如果是动态扩展，无法申请到足够内存OOM，如果是固定，线程请求的栈容量超过固定值，则StackOverflowError")]),v._v(" "),_("li",[v._v("使用-Xss (记忆：站着做一个小手术，栈Xss)，设置线程的最大栈空间")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"-Xss设置",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210413112803.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210413112803.png",alt:"-Xss设置"}})])]),v._v(" "),_("h3",{attrs:{id:"栈的存储单位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈的存储单位"}},[v._v("#")]),v._v(" 栈的存储单位")]),v._v(" "),_("ul",[_("li",[v._v("每个线程都有自己的栈，栈中的"),_("code",[v._v("数据以栈帧格式存储")])]),v._v(" "),_("li",[v._v("线程上"),_("code",[v._v("正在执行的每个方法都各自对应一个栈帧")])]),v._v(" "),_("li",[v._v("栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息")]),v._v(" "),_("li",[_("code",[v._v("先进后出，后进先出")])]),v._v(" "),_("li",[_("code",[v._v("一条活动的线程中，一个时间点上，只会有一个活动的栈帧")]),v._v("。只有当前正在执行的方法的栈顶栈帧是有效的，这个称为"),_("strong",[v._v("当前栈帧")]),v._v("，对应方法是"),_("strong",[v._v("当前方法")]),v._v("，对应类是"),_("strong",[v._v("当前类")])])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"活动线程",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210414134430.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210414134430.png",alt:"活动线程"}})])]),v._v(" "),_("ul",[_("li",[v._v("执行引擎运行的所有字节码指令只针对当前栈帧进行操作")]),v._v(" "),_("li",[v._v("如果方法中调用了其他方法，对应的新的栈帧会被创建出来，放在顶端，成为新的当前帧")])]),v._v(" "),_("h3",{attrs:{id:"栈运行原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈运行原理"}},[v._v("#")]),v._v(" 栈运行原理")]),v._v(" "),_("ul",[_("li",[v._v("不同线程中包含的栈帧"),_("strong",[v._v("不允许存在相互引用")])]),v._v(" "),_("li",[_("strong",[v._v("当前方法调用了其他方法")]),v._v("，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧")]),v._v(" "),_("li",[v._v("两种返回方式：一种是正常的函数返回，"),_("strong",[v._v("使用return指令")]),v._v("，另外一种是"),_("strong",[v._v("抛出异常")]),v._v("，不管哪种方式，都会导致栈帧被弹出")])]),v._v(" "),_("h3",{attrs:{id:"栈帧的内部结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈帧的内部结构"}},[v._v("#")]),v._v(" 栈帧的内部结构")]),v._v(" "),_("ul",[_("li",[v._v("局部变量表 Local Variables")]),v._v(" "),_("li",[v._v("操作数栈 Operand Stack (或表达式栈)")]),v._v(" "),_("li",[v._v("动态链接 Dynamic Linking (或指向运行时常量池的方法引用)")]),v._v(" "),_("li",[v._v("方法返回地址 Return Address (或方法正常退出或者异常退出的定义)")]),v._v(" "),_("li",[v._v("一些附加信息")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"内部结构",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210414150056.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210414150056.png",alt:"内部结构"}})])]),v._v(" "),_("h3",{attrs:{id:"局部变量表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#局部变量表"}},[v._v("#")]),v._v(" 局部变量表")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量")]),v._v("，数据类型包括各类基本数据类型，对象引用，以及return Address类型")]),v._v(" "),_("li",[v._v("建立在线程的栈上，"),_("strong",[v._v("是线程私有的，因此不存在数据安全问题")])]),v._v(" "),_("li",[v._v("容量大小是在"),_("code",[v._v("编译期")]),v._v("确定下来的，并保存在方法的Code属性的maximum local variables数据项中")]),v._v(" "),_("li",[v._v("存放编译期可知的各种基本数据类型（8种），引用类型（reference）,returnAddress 类型")]),v._v(" "),_("li",[v._v("最基本的"),_("code",[v._v("存储单元是slot")]),v._v("，32位占用一个slot，64位类型（long和double）占用两个slot")]),v._v(" "),_("li",[v._v("局部变量表中的变量"),_("strong",[v._v("只有在当前方法调用中有效")]),v._v("，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。")]),v._v(" "),_("li",[v._v("方法调用结束后，"),_("code",[v._v("随着方法栈帧的销毁，局部变量表也会随之销毁")])])]),v._v(" "),_("h4",{attrs:{id:"slot"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#slot"}},[v._v("#")]),v._v(" Slot")]),v._v(" "),_("ul",[_("li",[v._v("JVM虚拟机"),_("strong",[v._v("会为局部变量表中的每个Slot都分配一个访问索引")]),v._v("，通过这个索引即可成功访问到局部变量表中指定的局部变量值")]),v._v(" "),_("li",[v._v("如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415111022.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415111022.png",alt:""}})])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415111035.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415111035.png",alt:""}})])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("栈帧中的局部变量表中的槽位是可以重复的")]),v._v("，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415143748.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415143748.png",alt:""}})])]),v._v(" "),_("h4",{attrs:{id:"补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[v._v("#")]),v._v(" 补充")]),v._v(" "),_("p",[v._v("在栈帧中，与性能调优关系最密切的部分，就是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递")]),v._v(" "),_("p",[_("strong",[v._v("局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收")])]),v._v(" "),_("h3",{attrs:{id:"操作数栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作数栈"}},[v._v("#")]),v._v(" 操作数栈")]),v._v(" "),_("ul",[_("li",[v._v("可以使用数组和链表来实现，操作数栈就是使用数组来实现的")]),v._v(" "),_("li",[_("strong",[v._v("在方法执行的过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈")])])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415112019.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415112019.png",alt:""}})])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中")]),v._v("，并更新程序计数器中下一条需要执行的字节码指令")]),v._v(" "),_("li",[_("strong",[v._v("Java虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈")])]),v._v(" "),_("li",[v._v("主要用于"),_("strong",[v._v("保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间")])]),v._v(" "),_("li",[v._v("当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，"),_("strong",[v._v("这个方法的操作数栈是空的")])]),v._v(" "),_("li",[v._v("每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好")]),v._v(" "),_("li",[v._v("栈中，"),_("code",[v._v("32bit")]),v._v("类型占用"),_("code",[v._v("一个")]),v._v("栈单位深度，"),_("code",[v._v("64bit")]),v._v("类型占用"),_("code",[v._v("两个")]),v._v("栈单位深度")]),v._v(" "),_("li",[v._v("操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成    一次数据访问")]),v._v(" "),_("li",[_("strong",[v._v("栈顶缓存技术")]),v._v("：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率")])]),v._v(" "),_("h3",{attrs:{id:"动态链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[v._v("#")]),v._v(" 动态链接")]),v._v(" "),_("ul",[_("li",[v._v("每一个栈帧内部都包含一个"),_("strong",[v._v("指向运行时常量池中该帧所属方法的引用")])]),v._v(" "),_("li",[v._v("目的是为了支持当前方法的代码能够实现"),_("strong",[v._v("动态链接")]),v._v("，比如invokedynamic指令")]),v._v(" "),_("li",[v._v("在java源文件被编译成字节码文件中时，所有的变量、方法引用都作为符号引用，保存在class文件的常量池中。")]),v._v(" "),_("li",[v._v("描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的")]),v._v(" "),_("li",[_("strong",[v._v("动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用")])]),v._v(" "),_("li",[_("strong",[v._v("常量池在字节码文件中，运行时常量池在运行时的方法区中")])])]),v._v(" "),_("h3",{attrs:{id:"方法的调用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法的调用"}},[v._v("#")]),v._v(" 方法的调用")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("静态链接")]),v._v("：当一个字节码文件被装载进JVM内部时，如果被"),_("strong",[v._v("调用的目标方法在编译期可知")]),v._v("，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接")]),v._v(" "),_("li",[_("code",[v._v("动态链接")]),v._v("：如果"),_("strong",[v._v("被调用的方法无法再编译期被确定下来")]),v._v("，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接")]),v._v(" "),_("li",[v._v("方法的绑定：\n"),_("ul",[_("li",[_("strong",[v._v("绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次")])]),v._v(" "),_("li",[_("code",[v._v("早期绑定")]),v._v("：被调用的目标方法如果再编译期可知，且运行期保持不变")]),v._v(" "),_("li",[_("code",[v._v("晚期绑定")]),v._v("：被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法")])])]),v._v(" "),_("li",[v._v("Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义")]),v._v(" "),_("li",[v._v("如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法")]),v._v(" "),_("li",[_("code",[v._v("虚方法和非虚方法")]),v._v("：\n"),_("ul",[_("li",[v._v("非虚方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法；"),_("strong",[v._v("静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法")])]),v._v(" "),_("li",[v._v("其他方法称为虚方法")])])])]),v._v(" "),_("h3",{attrs:{id:"方法调用指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法调用指令"}},[v._v("#")]),v._v(" 方法调用指令")]),v._v(" "),_("p",[v._v("普通调用指令")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("invokestatic")]),v._v("：调用静态方法，解析阶段确定唯一方法版本")]),v._v(" "),_("li",[_("code",[v._v("invokevirtual")]),v._v("：调用所有虚方法")]),v._v(" "),_("li",[_("code",[v._v("invokeinterface")]),v._v("：调用接口方法，虚方法")]),v._v(" "),_("li",[_("code",[v._v("invokespecial")]),v._v("：调用"),_("init",[v._v("方法，私有及父类方法，解析阶段确定唯一方法版本")])],1),v._v(" "),_("li",[_("strong",[v._v("其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法")])]),v._v(" "),_("li",[v._v("动态调用指令JDK1.7新增："),_("code",[v._v("invokedynamic")]),v._v(" 动态解析出需要调用的方法，然后执行")]),v._v(" "),_("li",[v._v("直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式\n"),_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415113000.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415113000.png",alt:""}})])])]),v._v(" "),_("p",[v._v("静态语言和动态语言区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言，Java是静态类型语言，动态调用指令增加了动态语言的特性")]),v._v(" "),_("p",[_("strong",[v._v("静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息")])]),v._v(" "),_("h3",{attrs:{id:"方法重写的本质"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法重写的本质"}},[v._v("#")]),v._v(" 方法重写的本质")]),v._v(" "),_("ul",[_("li",[v._v("找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C")]),v._v(" "),_("li",[v._v("如果在类型C中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过，则返回"),_("code",[v._v("java.lang.IllegalAccessError")]),v._v("异常")]),v._v(" "),_("li",[v._v("否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程。* 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常")])]),v._v(" "),_("h3",{attrs:{id:"虚方法表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚方法表"}},[v._v("#")]),v._v(" 虚方法表")]),v._v(" "),_("ul",[_("li",[v._v("面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找")]),v._v(" "),_("li",[v._v("每个类都有一个虚方法表，表中存放着各个方法的实际入口")]),v._v(" "),_("li",[_("strong",[v._v("虚方法表会在类加载的链接阶段被创建，并开始初始化")]),v._v("，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完毕")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210415113144.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210415113144.png",alt:""}})])]),v._v(" "),_("h3",{attrs:{id:"方法返回地址"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法返回地址"}},[v._v("#")]),v._v(" 方法返回地址")]),v._v(" "),_("ul",[_("li",[v._v("存放调用"),_("code",[v._v("该方法的pc寄存器的值")])]),v._v(" "),_("li",[v._v("无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，"),_("strong",[v._v("调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址")]),v._v("。")]),v._v(" "),_("li",[v._v("异常退出的，返回地址是通过异常表来确定，栈帧中一般不会保存这部分信息")]),v._v(" "),_("li",[v._v("执行引擎遇到任意一个方法返回的字节码指令（return）,会有返回值传递给上层的方法调用者，简称正常完成出口")]),v._v(" "),_("li",[v._v("返回指令包括："),_("strong",[v._v("ireturn返回值是boolean，byte，char，short，和int类型时使用，lreturn，dreturn，areturn")])]),v._v(" "),_("li",[v._v("本质上，方法的退出就是当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去。")]),v._v(" "),_("li",[_("strong",[v._v("正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值")])])]),v._v(" "),_("h3",{attrs:{id:"一些附加信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一些附加信息"}},[v._v("#")]),v._v(" 一些附加信息")]),v._v(" "),_("p",[v._v("允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况")]),v._v(" "),_("h2",{attrs:{id:"本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),_("ul",[_("li",[v._v("Java虚拟机栈管理Java方法的调用，而"),_("strong",[v._v("本地方法栈用于管理本地方法的调用")])]),v._v(" "),_("li",[v._v("本地方法栈，也是线程私有的。")]),v._v(" "),_("li",[v._v("允许被实现成固定或者是可动态扩展的内存大小：内存溢出情况和Java虚拟机栈相同")]),v._v(" "),_("li",[v._v("使用C语言实现")]),v._v(" "),_("li",[v._v("具体做法是Native Method Stack 中登记native方法，在Execution Engine执行时加载到本地方法库")]),v._v(" "),_("li",[_("strong",[v._v("当某个线程调用一个本地方法时，就会进入一个全新，不受虚拟机限制的世界，它和虚拟机拥有同样的权限。")])]),v._v(" "),_("li",[v._v("并不是所有的JVM都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等")]),v._v(" "),_("li",[v._v("Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一")])]),v._v(" "),_("h2",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("h3",{attrs:{id:"核心概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#核心概述"}},[v._v("#")]),v._v(" 核心概述")]),v._v(" "),_("ul",[_("li",[v._v("一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域")]),v._v(" "),_("li",[v._v("Java堆区在JVM启动的时候即被创建，其空间大小也就确认了。堆内存的大小是可调节的")]),v._v(" "),_("li",[v._v("Java虚拟机规范规定，堆可以处于"),_("strong",[v._v("物理上不连续")]),v._v("的内存空间中，但在"),_("strong",[v._v("逻辑上它应该被视为连续的")])]),v._v(" "),_("li",[v._v("所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）")]),v._v(" "),_("li",[_("code",[v._v("几乎")]),v._v("所有的对象实例都在这里分配内存")]),v._v(" "),_("li",[v._v("数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，引用指向对象或者数组在堆中的位置")]),v._v(" "),_("li",[v._v("方法结束后，堆中的对象不会马上被移除，"),_("strong",[v._v("仅仅在垃圾收集的时候才会被移除")])]),v._v(" "),_("li",[v._v("堆是GC执行垃圾回收的重点区域")])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"堆控件细分",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210428161227.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210428161227.png",alt:"堆控件细分"}})])]),v._v(" "),_("ul",[_("li",[v._v("设置堆内存的大小与OOM："),_("strong",[v._v("-Xms ：小秘书表示堆空间的起始内存，-Xmx：小明星表示堆空间的最大内存")])]),v._v(" "),_("li",[v._v("初始内存大小是："),_("code",[v._v("物理电脑内存大小 / 64")]),v._v("，最大内存大小是："),_("code",[v._v("物理内存大小 / 4")])]),v._v(" "),_("li",[_("code",[v._v("jps")]),v._v("查看当前程序运行的进程，jstat查看JVM在gc时的统计信息，"),_("code",[v._v("jstat -gc 进程号")])]),v._v(" "),_("li",[v._v("通常将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾会后清理完堆区后，不需要重新分隔计算堆区的大小，从而提高性能")])]),v._v(" "),_("h4",{attrs:{id:"年轻代和老年代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#年轻代和老年代"}},[v._v("#")]),v._v(" 年轻代和老年代")]),v._v(" "),_("ul",[_("li",[v._v("新生代与老年代空间"),_("strong",[v._v("默认比例1:2")]),v._v("，"),_("code",[v._v("-XX:NewRatio=2")]),v._v("，表示新生代占1，老年代占2，新生代占整个堆的1/3")]),v._v(" "),_("li",[v._v("在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是："),_("strong",[v._v("8:1:1")]),v._v("，但实际是"),_("code",[v._v("6:1:1")]),v._v("，"),_("strong",[v._v("需要手动设置-XX:SurvivorRatio=8")])]),v._v(" "),_("li",[_("strong",[v._v("几乎所有的")]),v._v("Java对象都是在Eden区被new出来的")])]),v._v(" "),_("h4",{attrs:{id:"对象分配过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象分配过程"}},[v._v("#")]),v._v(" 对象分配过程")]),v._v(" "),_("ol",[_("li",[v._v("new的对象先放在Eden区，此区有大小限制")]),v._v(" "),_("li",[v._v("当创建新对象，Eden空间填满时，会触发YGC(MinorGC)，将Eden不再被其他对象引用的对象进行销毁。再加载新的对象放到Eden区")]),v._v(" "),_("li",[v._v("将Eden中剩余的对象移到幸存者0区")]),v._v(" "),_("li",[v._v("再次触发垃圾回收，此时上次幸存者下来的，放在幸存者0区的，如果没有回收，就会放到幸存者1区")]),v._v(" "),_("li",[v._v("再次经历垃圾回收，又会将幸存者重新放回幸存者0区，依次类推")]),v._v(" "),_("li",[v._v("可以设置一个次数，"),_("strong",[v._v("默认是15次，超过15次，则会将幸存者区幸存下来的转去老年区")]),v._v("，"),_("code",[v._v("-XX:MaxTenuringThreshold=N进行设置")])])]),v._v(" "),_("p",[_("a",{attrs:{"data-fancybox":"",title:"过程",href:"https://gitee.com/jtxyh/blogImg/raw/master/20210429112539.png"}},[_("img",{attrs:{src:"https://gitee.com/jtxyh/blogImg/raw/master/20210429112539.png",alt:"过程"}})])]),v._v(" "),_("p",[v._v("总结：")]),v._v(" "),_("ul",[_("li",[v._v("针对幸存者s0，s1区的总结："),_("strong",[v._v("复制之后有交换，谁空谁是to")])]),v._v(" "),_("li",[v._v("垃圾回收："),_("strong",[v._v("频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集")])]),v._v(" "),_("li",[v._v("触发YGC，幸存者区就会进行回收，不会主动进行回收")]),v._v(" "),_("li",[v._v("超大对象eden放不下，就要看Old区大小是否可以放下，old区也放不下，需要FullGC（MajorGC），这两GC概念还是有区别的")])]),v._v(" "),_("h3",{attrs:{id:"minorgc，majorgc，fullgc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minorgc，majorgc，fullgc"}},[v._v("#")]),v._v(" MinorGC，MajorGC，FullGC")]),v._v(" "),_("p",[v._v("针对HotSpot VM实现，它里面的GC按照"),_("code",[v._v("回收区域")]),v._v("分为两大种类型："),_("strong",[v._v("一种是部分收集(MinorGC，MajorGC)，一种是整堆收集(FullGC)")])]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("部分收集")]),v._v("：不是完整收集整个Java堆的垃圾收集")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("整堆收集")]),v._v("：收集整个"),_("strong",[v._v("Java堆和方法区")]),v._v("的垃圾收集")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("新生代收集(MinorGC/YoungGC)")]),v._v("：只是新生代的垃圾收集")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("老年代收集(MajorGC/OldGC)")]),v._v("：只是老年代的垃圾收集")]),v._v(" "),_("ul",[_("li",[v._v("目前，只有CMS GC会有单独收集老年代的行为")]),v._v(" "),_("li",[_("strong",[v._v("很多时候MajorGC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收")])])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("混合收集(MixedGC)")]),v._v("：收集整个新生代以及部分老年代的垃圾收集，目前只有G1 GC会有这种行为")])])]),v._v(" "),_("h4",{attrs:{id:"新生代gc-minorgc-的触发条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新生代gc-minorgc-的触发条件"}},[v._v("#")]),v._v(" 新生代GC(MinorGC)的触发条件")]),v._v(" "),_("ul",[_("li",[v._v("当"),_("strong",[v._v("年轻代空间不足")]),v._v("时，就会触发MinorGC，这里的年轻代指的是"),_("strong",[v._v("Eden代满")]),v._v("，Survivor满不会触发GC。每次MinorGC会清理年轻代的内存")]),v._v(" "),_("li",[v._v("因为Java对象大多朝生夕灭，所以MinorGC非常频繁")]),v._v(" "),_("li",[v._v("MinorGC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行")])]),v._v(" "),_("h4",{attrs:{id:"老年代gc-majorgc-fullgc-触发条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#老年代gc-majorgc-fullgc-触发条件"}},[v._v("#")]),v._v(" 老年代GC(MajorGC/FullGC)触发条件")]),v._v(" "),_("ul",[_("li",[v._v("指发生在"),_("strong",[v._v("老年代的GC")]),v._v("，对象从老年代消失，我们说“”MajorGC“”FullGC“”发生了")]),v._v(" "),_("li",[v._v("出现了MajorGC，经常会伴随至少一次MinorGC\n"),_("ul",[_("li",[v._v("非绝对，在Parallel Scavenge收集器的收集策略里就直接进行MajorGC的策略选择过程")]),v._v(" "),_("li",[v._v("也就是老年代空间不足，会先尝试触发MinorGC，如果之后空间还不足，则触发MajorGC")])])]),v._v(" "),_("li",[_("strong",[v._v("MajorGC的速度比MinorGC慢10倍以上")]),v._v("，STW的时间更长")]),v._v(" "),_("li",[v._v("如果MajorGC后，内存还不足，就报OOM了")])]),v._v(" "),_("h4",{attrs:{id:"fullgc的触发机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fullgc的触发机制"}},[v._v("#")]),v._v(" FullGC的触发机制")]),v._v(" "),_("ul",[_("li",[v._v("调用System.gc()时，系统建议执行FullGC，但是不必然执行")]),v._v(" "),_("li",[v._v("老年代空间不足")]),v._v(" "),_("li",[v._v("方法区空间不足")]),v._v(" "),_("li",[v._v("通过MinorGC后进入老年代的平均大小，大于老年代的可用内存")]),v._v(" "),_("li",[v._v("由Eden区，Survivor 0区向Survivor 1区复制时，对象的大小大于ToSpace可用内存，则把改对象转存到老年代，且老年代的可用内存小于该对象的大小")]),v._v(" "),_("li",[v._v("FullGC是开发或调优中尽量要避免的，这样暂停时间会短一些")])])])}),[],!1,null,null,null);t.default=r.exports}}]);